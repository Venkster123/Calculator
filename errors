engine/parser.y:293.9-14: warning: empty rule for typed nonterminal, and no action [-Wother]
 pack:	%empty
         ^^^^^^
engine/parser.y: warning: 1 nonterminal useless in grammar [-Wother]
engine/parser.y: warning: 1 rule useless in grammar [-Wother]
engine/parser.y:84.17-20: warning: nonterminal useless in grammar: sbex [-Wother]
 %type	<tree>	sbex
                 ^^^^
engine/parser.y:218.9-220.1: warning: rule useless in grammar [-Wother]
 sbex:	SUBSCRIPT LBRACE expr RBRACE {
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
engine/parser.y: warning: 55 shift/reduce conflicts [-Wconflicts-sr]
engine/parser.y: warning: 23 reduce/reduce conflicts [-Wconflicts-rr]
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:185:16: error: expected ‘)’ before ‘str’
  ADD_BINARY_OP(str, Z, Z, Z);           \
                ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:186:16: error: expected ‘)’ before ‘str’
  ADD_BINARY_OP(str, R, R, R);           \
                ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:187:16: error: expected ‘)’ before ‘str’
  ADD_BINARY_OP(str, Q, Q, Q);           \
                ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:188:16: error: expected ‘)’ before ‘str’
  ADD_BINARY_OP(str, CR, CR, CR);           \
                ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:189:16: error: expected ‘)’ before ‘str’
  ADD_BINARY_OP(str, CQ, CQ, CQ);           \
                ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:191:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:191:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:192:52: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
                                                    ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:192:52: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
                                                    ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:193:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:193:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:194:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:194:22: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
                      ^
tests/../engine/barn.h:28:38: note: in definition of macro ‘ADD_BINARY_OP’
     return new operand <O> (a->get() str b->get());   \
                                      ^~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:195:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
                                            ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:195:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
                                                      ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:195:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
                                            ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:195:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
                                                      ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:196:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:196:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
                                                      ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:196:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:196:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
                                                      ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:197:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:197:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
                                                      ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:197:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:197:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
                                                      ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:198:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:198:57: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
                                                         ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:198:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
                                            ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:198:57: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
                                                         ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:199:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
                                            ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:199:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
                                                      ^
tests/../engine/barn.h:52:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In lambda function:
tests/../engine/barn.h:199:44: error: expected primary-expression before ‘(’ token
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
                                            ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h:199:54: error: expected ‘)’ before ‘str’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
                                                      ^
tests/../engine/barn.h:63:29: note: in definition of macro ‘ADD_HETER_BINARY_OP_FTR’
     return new operand <O> (ftr);   \
                             ^~~
tests/../engine/barn.h: In instantiation of ‘barn<R, Z>::barn()::<lambda(const std::vector<token*>&)> [with R = double; Z = int]’:
tests/../engine/barn.h:182:2:   required from ‘struct barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const class std::vector<token*>&)>’
tests/../engine/barn.h:182:2:   required from ‘barn<R, Z>::barn() [with R = double; Z = int]’
tests/../engine/node.h:182:20:   required from ‘node<T, U>::node(std::__cxx11::string, vtable<T>, node<T, U>::params) [with T = double; U = int; std::__cxx11::string = std::__cxx11::basic_string<char>; node<T, U>::params = std::vector<variable<double>, std::allocator<variable<double> > >]’
tests/tests.cpp:25:38:   required from here
tests/../engine/barn.h:28:12: error: no matching function for call to ‘operand<Complex<Rational<int> > >::operand(double)’
     return new operand <O> (a->get() str b->get());   \
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:17:0,
                 from tests/tests.cpp:10:
tests/../engine/operand.h:118:1: note: candidate: operand<data_t>::operand(const operand<data_t>&) [with data_t = Complex<Rational<int> >]
 operand <data_t> ::operand(const operand &other) : val(other.val) {}
 ^~~~~~~~~~~~~~~~
tests/../engine/operand.h:118:1: note:   no known conversion for argument 1 from ‘double’ to ‘const operand<Complex<Rational<int> > >&’
tests/../engine/operand.h:115:1: note: candidate: operand<data_t>::operand(data_t) [with data_t = Complex<Rational<int> >]
 operand <data_t> ::operand(data_t data) : val(data) {}
 ^~~~~~~~~~~~~~~~
tests/../engine/operand.h:115:1: note:   no known conversion for argument 1 from ‘double’ to ‘Complex<Rational<int> >’
tests/../engine/operand.h:112:1: note: candidate: operand<data_t>::operand() [with data_t = Complex<Rational<int> >]
 operand <data_t> ::operand () : val(data_t()) {}
 ^~~~~~~~~~~~~~~~
tests/../engine/operand.h:112:1: note:   candidate expects 0 arguments, 1 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h: In instantiation of ‘barn<R, Z>::barn() [with R = double; Z = int]’:
tests/../engine/node.h:182:20:   required from ‘node<T, U>::node(std::__cxx11::string, vtable<T>, node<T, U>::params) [with T = double; U = int; std::__cxx11::string = std::__cxx11::basic_string<char>; node<T, U>::params = std::vector<variable<double>, std::allocator<variable<double> > >]’
tests/tests.cpp:25:38:   required from here
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:182:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(+);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<int>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = int; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = int]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = int]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:183:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(-);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<int>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:185:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);           \
  ^~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = int; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = int]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = int]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:185:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);           \
  ^~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:186:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);           \
  ^~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:186:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);           \
  ^~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:187:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);           \
  ^~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:187:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);           \
  ^~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:188:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);           \
  ^~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:188:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);           \
  ^~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:189:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);           \
  ^~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:189:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);           \
  ^~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:191:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:192:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:192:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:192:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:192:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, Q, Q, Q(a->get()) str b->get());      \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:193:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:194:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);          \
  ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:195:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:195:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:195:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:195:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, R, CQ, CR, CR(a->get() str R(b->get().real()), R(b->get().imag())));  \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:196:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:196:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:196:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:196:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CR, CR, CR(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:197:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:197:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:197:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:197:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Z, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:198:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:198:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:198:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:198:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CR, CR, CR(R(a->get()) str b->get().real(), b->get().imag()));   \
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:47:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});         \
  ~ 
tests/../engine/barn.h:199:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:45:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:199:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:58:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#B) + ") " + std::string(#str) + " $2 (" + std::string(#A) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (ftr);   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:199:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:56:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:199:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP_FTR’
  ADD_HETER_BINARY_OP_FTR(str, Q, CQ, CQ, CQ(a->get() str b->get().real(), b->get().imag()));
  ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<int>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = int; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = int]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = int]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:201:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(*);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<int>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = int; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = int]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = int]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:89:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Z, Z, Z);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:90:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, R, R, R);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:91:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, Q, Q, Q);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:92:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CR, CR, CR);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:93:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, CQ, CQ, CQ);   \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:95:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Z, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Rational<int> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Rational<int>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Rational<int>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Rational<int>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:96:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, Q, Q);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<double>::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = double; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = double]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = double]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:97:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, Q, R);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:98:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:99:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, R, CQ, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:100:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:101:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Z, CQ, CQ);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<double> >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<double>; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<double>]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<double>]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:102:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CR, CR);  \
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:68:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, A, B, O)  \
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:23:3: error: no matching function for call to ‘operation<Complex<Rational<int> > >::operation(<brace-enclosed initializer list>)’
   new operation <O> {std::string(#str), "$1 (" + std::string(#A) + ") " + std::string(#str) + " $2 (" + std::string(#B) + ")", 2, \
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [&](const std::vector <token *> &ins) {      \
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <A> *a = dynamic_cast <operand <A> *> (ins[0]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     operand <B> *b = dynamic_cast <operand <B> *> (ins[1]);    \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              \
              ~
     return new operand <O> (a->get() str b->get());   \
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }          \
    ~~~~~~~~~~~~
  }});
  ~ 
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from tests/../engine/barn.h:18:0,
                 from tests/tests.cpp:10:
tests/../engine/operation.h:93:1: note: candidate: operation<T>::operation(const string&, const string&, std::size_t, std::function<token*(const std::vector<token*>&)>) [with T = Complex<Rational<int> >; std::__cxx11::string = std::__cxx11::basic_string<char>; std::size_t = long unsigned int]
 operation <T> ::operation(const std::string &in, const std::string &out,
 ^~~~~~~~~~~~~
tests/../engine/operation.h:93:1: note:   no known conversion for argument 4 from ‘barn<R, Z>::barn() [with R = double; Z = int]::<lambda(const std::vector<token*>&)>’ to ‘std::function<token*(const std::vector<token*>&)>’
tests/../engine/operation.h:84:1: note: candidate: operation<T>::operation(const operation<T>&) [with T = Complex<Rational<int> >]
 operation <T> ::operation(const operation &other)
 ^~~~~~~~~~~~~
tests/../engine/operation.h:84:1: note:   candidate expects 1 argument, 4 provided
tests/../engine/operation.h:81:1: note: candidate: operation<T>::operation() [with T = Complex<Rational<int> >]
 operation <T> ::operation() : input(""), output(""), ops(0) {}
 ^~~~~~~~~~~~~
tests/../engine/operation.h:81:1: note:   candidate expects 0 arguments, 4 provided
In file included from tests/tests.cpp:10:0:
tests/../engine/barn.h:21:2: error: no matching function for call to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::push_back(<brace-enclosed initializer list>)’
  ops.push_back({{std::string(#str), std::vector <std::type_index>   \
  ^
tests/../engine/barn.h:69:2: note: in expansion of macro ‘ADD_BINARY_OP’
  ADD_BINARY_OP(str, B, A, O)
  ^~~~~~~~~~~~~
tests/../engine/barn.h:103:2: note: in expansion of macro ‘ADD_HETER_BINARY_OP’
  ADD_HETER_BINARY_OP(str, Q, CQ, CQ);
  ^~~~~~~~~~~~~~~~~~~
tests/../engine/barn.h:202:2: note: in expansion of macro ‘ADD_BINARY_OP_SET’
  ADD_BINARY_OP_SET(/);
  ^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/vector:64:0,
                 from tests/tests.cpp:4:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type& {aka const std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&}’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>; _Alloc = std::allocator<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >; std::vector<_Tp, _Alloc>::value_type = std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*> >::value_type&& {aka std::pair<std::pair<std::__cxx11::basic_string<char>, std::vector<std::type_index> >, token*>&&}’
make: *** [tests] Error 1
