= Zhetapi ℤHΠ
:sectnums:
:toc2:

# Introduction
image::zhetapi-logo.png[]

Zhetapi (ℤHΠ) is a C++ (14) computation library that was built in the hopes of
making mathematical computation and algorithmic research more convenient to the
users.

This project is being developed on a Linux environment and has only been tested
for it. It is a work in progress.

# Features

## Evaluation of Complex Expressions

The library can evaluate complex expressions, which have operands of various
types, such as integers, rational numbers, complex numbers, vectors and
matrices.

Through the RTTI mechanism of C++ , the framework of the library allows the
evaluation to be sensitive to certain types of operands and their corresponding
operations. For example, multiplication of two integers yields an integers, the
division of two rational numbers stays rational, and the product of a matrix,
whose components are integers, with a rational scalar yields a matrix with
rational components.

The `expression.h` header contains `expr()` and `exprf()`, which return
the value of the passed expression as a string. The difference in these two lies
in the fact that `exprf()` takes in a formatted string, while `expr()`
takes a string object.

```{cpp}
// Not formatted, prints "1.0"
cout << expr("1 + 2!/2.0") << endl;

// Formatted, also prints "1.0"
cout << exprf("%d + %d!/2.0", 1, 2) << endl;
```

## Customization of Operations

As mentioned above, the engine is sensitive to overloads of certain operations.
On top of this, users can create their own set of operations and corresponding
overloads or add more overloads. This is possible through the `Barn` class and
macros provided by the library.

```{cpp}
// Define the operation
// &: (Z, Z) to Z,
// &(a, b) = a(a + b)
__add_binary_operation_ftr(&, Z, Z, Z, (a->get() + b->get()) * a->get());

// Define the operation
// &: (R, Q) to R,
// &(a, b) = a(a + b)
__add_heterogenous_binary_operation_ftr(&, R, Q, R, (a->get() + b->get()) * a->get());

// Define the operation
// pop: Z to Z
// pop(a) = a(a + 1)
__add_unary_operation_ftr(pop, Z, Z, (a->get() + 1) * a->get());
```

The supported macros for operation creation are listed below.

|===

| Macro | Arguments | Desciption

| `__add_binary_operation` | str, A, B, O | Creates a binary operation `str`
whose input types and A and B (in that order), and whose output type is O. The
output of the operation is `a str b`, where `str` is treated as a native binary
operation.

| `__add_heterogenous_binary_operation` | str, A, B, O | Equivalent to
`__add_binary_operation`, but adds `str` as a binary operation between A and B
and B and A. The output type remains O for all operations added with this macro.

| `__add_binary_operation_ftr` | str, A, B, O, ftr | Equivalent to
`__add_binary_operation`, but the last argument specifies how the operation is
actually performed. Used `a->get()` to retrieve the value of operand with type A
and `b->get()` to retrieve the value of the operand with type B.

| `__add_heterogenous_binary_operation_ftr` | str, A, B, O, ftr | Equivalent to
two calls of `__add_binary_operation_ftr`, one in which the order of the
operands is `A str B` and the other in which the order is `B str A`.

| `__add_binary_operation_set` | str | Adds the binary operation `str` between
all complex types (Z, Q, R, CZ, CQ, CR). For example, by the default the engine
uses `__add_binary_operation_set(+)` to establish the addition operations
between the complex types.

| `__add_unary_operation` | str, I, O | Adds the unary operation `str` whose
input type is I and output type is O. The result of this operation is `str(I)`.

| `__add_unary_operation_ftr` | str, I, O, ftr | Similar to
`__add_unary_operation_ftr`, but now the result of the operation can be
specified as the third argument. Use `in->get()` to retrieve the value of the
input.

|===

The `typedef` s `Z`, `Q`, and `R` in the example refer to integer, rational and
real operands. Below is a table of all supported operand types.

|===

| `typedef` | Operand type

| `Z` | Integers, Z
| `Q` | Rationals, Q
| `R` | Reals, R

| `CZ` | Gaussian integer, Z[i]
| `CQ` | Complex number with rational parts, Q[i]
| `CR` | Complex numbers, C

| `VZ` | Vector with integral components
| `VQ` | Vector with rational components
| `VR` | Vector with real components

| `VCZ` | Vector with components in Z[i]
| `VCQ` | Vector with components in Q[i]
| `VCR` | Vector with complex components

| `MZ` | Matrix with integral components
| `MQ` | Matrix with rational components
| `MR` | Matrix with real components

| `MCZ` | Matrix with components in Z[i]
| `MCQ` | Matrix with components in Q[i]
| `MCR` | Matrix with complex components

|===

As of right now, however, due to how the engine parses identifiers, the
only characters available for operation creation are alphabetic characters (a-z
and A-Z).

## Usage and Declaration of Variables

The library provides constructs that allow the user to store variables and
retrieve them in the scope of the `Barn` class. Users can then refer to these
variables, and their values can be retrieved or changed.

```{cpp}
Variable <double> x{"x", 46};

Barn <double, int> brn;

brn.add(x);

// Prints "[x] - 46"
cout << brn.get("x") << endl;

// Generates an exception
cout << brn.get("y") << endl;
```

## User Defined Functions

Users can create mathematical functions, which can then be used as any other C++
functor object.

```{cpp}
Function <double, int> f = "f(x) = x^2";

// Prints "10"
cout << f(10) << endl;

// Prints "9/16"
cout << f(Rational <int> {3, 4}) << endl;

// Prints "25.0"
cout << f(5.0) << endl;
```

## Calculus

An object of class `Function` can be differentiated in terms of any of its
variables, to get its gradients and such. This process is symbolic, which has
the advantage that one has a closed form for the derivative, but the
disadvantage that it could be very complicated.

```{cpp}
Function <double, int> f = "f(x) = x^2";

// Compute df/dx
Function <double, int> df = f.differentiate(0);

// Prints "f(x) = x^2"
cout << f << endl;

// Prints "df/dx(x) = 2x"
cout << df << endl;
```

## Linear Algebra

The library also provides ways in which the user can do linear algebra. The
classes `Vector` and `Matrix` come with a variety of methods on their own, which
include performing computation as well as manipulation of their representations.

In addition to these classes, the library provides standard algorithms such as Gram
Schmidt and LU Factorization (see below).

## Standard Algorithms

|===

| Function | Description | Engine Header

| `gram_schmidt` | Performs the Gram Schmidt process on the given
set of vectors.	| `algorithm.h`

| `gram_schmidt_normalized` | Same as `gram_schmidt` but returns a basis of
normalized vectors. | `algorithm.h`

| `lagrange_interpolate` | Performs Lagrange interpolation on the given set of
points. Returns the appropriate polynomial. | `algorithm.h`

| `lu_factorize` | Returns the LU factorization of a matrix. | `algorithm.h`

| `solve_linear_equation` | Solves the linear equation `Ax = b` given `A` and
`b`. | `algorithm.h`

| `reduced_polynomial_fitting` | Returns a polynomial that goes through the
given set of points. Differs from `lagrange_interpolate` in that it returns a
simplified polynomial. | `algorithm.h`

| `gradient_descent` | Applies gradient descent to a given function on the given
set of data. | `algorithm.h`

| `find_root` | Uses Newton's method to find the root of the given function. |
`algorithm.h`

| `solve_hlde_constant` | Solves the homogeneous linear differential equation
with constant coefficients represented by the given polynomial. Returns a list
of functions as a basis to the solution space. | `calculus.h`

| `bernoulli_sequence_real` | Generates the first `n` terms of the Bernoulli
sequence. | `combinatorial.h`

| `bernoulli_sequence_rational` | Generates the first `n` terms of the Bernoulli
sequence as rational numbers. | `combinatorial.h`

| `bernoulli_number_real` | Generates the `n` th Bernoulli number.
| `combinatorial.h`

| `bernoulli_number_rational` | Generates the `n` th Bernoulli number as a
rational number.
| `combinatorial.h`

|===

## Overview of Usable Classes

Below are the currently usable classes.

|===

| Class Name | Description | Engine Header

| `Activation` | An activation in the standard machine learning context | `activations.hpp`
| `Barn` | A class which contains settings for other classes like functions | `rational.hpp`
| `Complex` | A complex number in mathematics | `complex.hpp`
| `Engine` | A class which contains information on legal simplification and
differentiations | `complex.hpp`
| `Function` | A mathematical function | `function.hpp`
| `Matrix` | A matrix in linear algebra | `matrix.hpp`
| `Network` | A deep neural network in machine learning | `network.hpp`
| `Optimizer` | A class which computes costs, in the standard machine learning
context | `optimizer.hpp`
| `Polynomial` | A polynomial in algebra | `polynomial.hpp`
| `Rational` | A rational number in algebra | `rational.hpp`
| `Tensor` | Represents a tensor in algebra | `tensor.hpp`
| `Vector` | A vector in linear algebra | `vector.hpp`

|===


# Modules

A description of each directory is presented below:

|===

| Directory | Description

| cfg |	Source for the Zhetapi manager, which allows users to change and add
rules for processes like simplification and differentiation of functions and
expressions.

| cli |	Code for the Command Line Interface (CLI) application of Zhetapi. The
CLI will allow the user to directly compute expressions and declare functions
from the command line -- it is essentially a calculator application like `octave`.

| engine | Contains the library template headers. All library features are
present in this module. It will later contain API functions.

| inc | Contains the source used in library template headers, and which are
optional to include. Includes code that is not meant to be seen by the users.

| physics | Side project involving the creation of a physics simulator.
Developed on Godot Engine.

| tests | Resources used to test library features.

| texifier | Code to convert plain text math to Latex. Used on the website to
turn results from plain text into Latex.

| web | Code to run the webserver for the Zhetapi website. This website
supports the computation of mathematical expressions and it also provides graphing
capabilities. This is still in early developement.

| zhp | Contains standard configurations for zhetapi classes, such as
simplifications for expression trees and derivative rules for function
differentiation.

|===

# Usage

The only prerequisite for using the library headers is Boost (preferably version
1.65.1, which is used in development), specifically the Spirit, Phoenix and
Fusion libraries.

## Zhetapi CLI

The Zhetapi CLI is a command line calculator application, similar to `octave`.
One can simply enter expressions to be calculated or define functions and
variables and then use them in later computations. The user can also enter
commands, by using a `#` before specifying the command name (ie. the `#list`
command lists all available commands).

# What Next?

## Simplification of Functions

Currently, objects of the `Function` class lack the complete ability to simplify
their representations. Some of this functionality does already exist, such as
the fact that adding/subtracting by 0 and multiplying/dividing by 1 are trivial
actions.

As an example which is not yet featuerd, it is not yet possible to have the
object recognize that `3xy + 5yx` is the same as `8xy`. This feature would also
help reduce the complexity of derivates of these objects.

## Integration and Differentiation

Symbolic differentiation is a current feature. However, integration is not. This
feature will be implemented as soon as the current framework has been properly
placed.  In addition, we would like to add other kinds of differentiation and
integration, such as automatic differentiation, and different types of numerical
integration (quadrature, etc.).

## Exact Forms of Numbers

One recognizes, simply by looking at the first few digits, that the number
`3.141592` is most nearly pi, and that the number `2.7182817` is most nearly
Euler's number. The hope is that at some point, the library will be able to
reach similar conclusions, through the help of integer relations algorithms such
as PSLQ.

## More Algorithms in Linear Algebra

Although there are a few standard linear algebra algorithms, the hope is that
more will be added. These include QR factorization, SVD, diagonalization, etc.

## Machine Learning

A solid foundation for linear algebra is already present in the library. The
next move would be to implement machine learning utilities, such as Deep Neural
Networks.

## Improve Semantics

The aim of the library is to allow the user to perform mathematical tasks with
ease. Thus, notational convenience of library features is important and is a
task that remains to be seen through.

# References

Below is a list of resources used in the making of this project.

 . Strang, Gilbert. _Introduction to Linear Algebra._ Wellesley, MA: Cambridge Press, 2016. Print.
 . Apostol, Tom M. _Calculus. Volume I_ New York: J. Wiley, 1967. Print.
 . Apostol, Tom M. _Calculus. Volume II_ Waltham, Mass: Blaisdell Pub. Co, 1967. Print.
 . Graham, Ronald L., Donald E. Knuth, and Oren Patashnik. _Concrete Mathematics
 : A Foundation For Computer Science._ Reading, Mass: Addison-Wesley, 1994. Print.
 . Stroustrup, Bjarne. _The C++ Programming Language._ Upper Saddle River, NJ: Addison-Wesley, 2013. Print.
 . Press, William H., et al. _Numerical Recipes : The Art of Scientific Computing._ Cambridge, UK New York: Cambridge University Press, 2007. Print.
